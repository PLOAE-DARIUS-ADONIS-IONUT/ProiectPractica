function [N, progressData] = NewtonInterpolationProgressData(x, f, z)
    n = numel(x) - 1;
    N = f(1);
    % Iniţializare struct array gol cu câmpurile folosite:
    steps = struct( ...
        'Stage',        {}, ...
        'k',            {}, ...
        'j',            {}, ...
        'p_denominator',{ }, ...
        'value',        {}, ...
        'p_z',          {}, ...
        'increment',    {}, ...
        'N_current',    {} );

    for k = 1:n
        s = 0;
        % 1) termeni de diferenţe divizate
        for j = 1:(k+1)
            p_den = 1;
            for i = 1:(k+1)
                if i~=j
                    p_den = p_den * (x(j) - x(i));
                end
            end
            val = f(j)/p_den;
            s = s + val;
            % adaugă un element struct
            steps(end+1) = struct( ...
                'Stage',        'DivDiff', ...
                'k',            k, ...
                'j',            j-1, ...
                'p_denominator',p_den, ...
                'value',        val, ...
                'p_z',          NaN, ...
                'increment',    NaN, ...
                'N_current',    NaN );
        end
        % 2) agregare cu produsul în z
        p_z = prod(z - x(1:k));
        incr = s * p_z;
        N = N + incr;
        steps(end+1) = struct( ...
            'Stage',        'Aggregate', ...
            'k',            k, ...
            'j',            NaN, ...
            'p_denominator',NaN, ...
            'value',        s, ...
            'p_z',          p_z, ...
            'increment',    incr, ...
            'N_current',    N );
    end

    % Convertim la tabel
    progressData = struct2table(steps);
end
